import { NextResponse } from "next/server";
import { PrismaClient } from "@prisma/client";
import { sendEmail } from "@/lib/gmail"; // Assuming Gmail utility exists
import { getFollowUpDate } from "@/lib/utils"; // Assuming utility exists
import { addToQueue } from "@/lib/redis"; // Assuming Redis utility exists

const prisma = new PrismaClient();

export async function PUT(
  request: Request,
  { params }: { params: { id: string } }
) {
  const { id } = params;
  const { content } = await request.json();

  try {
    const updatedEmail = await prisma.email.update({
      where: { id },
      data: { content },
    });
    return NextResponse.json(updatedEmail);
  } catch (error) {
    console.error(`Failed to update email ${id}:`, error);
    return NextResponse.json(
      { error: `Failed to update email ${id}` },
      { status: 500 }
    );
  }
}

export async function DELETE(
  request: Request,
  { params }: { params: { id: string } }
) {
  const { id } = params;

  try {
    await prisma.email.delete({
      where: { id },
    });
    return NextResponse.json({ message: `Email ${id} deleted` });
  } catch (error) {
    console.error(`Failed to delete email ${id}:`, error);
    return NextResponse.json(
      { error: `Failed to delete email ${id}` },
      { status: 500 }
    );
  }
}

// This route specifically handles sending an email draft
export async function POST(
  request: Request,
  { params }: { params: { id: string } }
) {
  const { id } = params;

  try {
    const email = await prisma.email.findUnique({
      where: { id },
    });

    if (!email) {
      return NextResponse.json({ error: "Email not found" }, { status: 404 });
    }

    if (email.status !== "draft" && email.status !== "pending") {
        return NextResponse.json({ error: `Email status is ${email.status}, cannot send` }, { status: 400 });
    }

    // Send the email using the Gmail utility
    await sendEmail({ to: email.recipient, subject: email.subject, text: email.content });

    // Update email status to sent
    const sentEmail = await prisma.email.update({
      where: { id: email.id },
      data: { status: "sent", sentAt: new Date() },
    });

    // Schedule follow-up if needed (only for initial emails, not chain replies)
    if (!email.threadId || email.threadId === email.id) { // Simple check if it's likely an initial email
      const followUpDate = getFollowUpDate(new Date());
      const followUp = await prisma.followUp.create({
        data: {
          emailId: sentEmail.id,
          clientId: sentEmail.clientId || "", // Assuming clientId is on Email or can be derived
          content: "", // Content will be generated by AI later
          status: "pending",
          scheduledAt: followUpDate,
        },
      });
      // Add follow-up to processing queue
       await addToQueue({ type: "follow-up", data: { followUpId: followUp.id } });
    }

    return NextResponse.json(sentEmail);
  } catch (error) {
    console.error(`Failed to send email ${id}:`, error);
    return NextResponse.json(
      { error: `Failed to send email ${id}` },
      { status: 500 }
    );
  }
} 